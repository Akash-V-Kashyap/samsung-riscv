# Samsung-RISCV
RISC-V is an open-standard instruction set architecture (ISA) rooted in the principles of Reduced Instruction Set Computer (RISC) design. Its open-source nature makes it freely available to anyone, enabling widespread adoption and fostering innovation in the development of custom processors tailored to specific use cases.

## Basic Details ðŸš€
#### -  Name: Akash V Kashyap
#### - College: Dayananda Sagar College of Engineering, Bengalore 560078
#### - Email ID: akashvkashyap@gmail.com
#### - GitHub Profile: Akash-V-Kashyap 
#### - LinkedIN Profile: [Akash V Kashyap](https://www.linkedin.com/in/akash-v-kashyap-336003261/)

## 
### 1. Download the Oracle Virtual Machine
![screenshot-1](https://github.com/user-attachments/assets/dd7eed6f-afc5-4a4d-9d28-5c94b033e330)

##
### 2. What is OpenLane?
OpenLane is an advanced silicon implementation platform that integrates open-source tools like Yosys, OpenROAD, Magic, KLayout, and other open-source or proprietary utilities.

##
### 3. Installed OpenLane in Ubuntu
![screenshot-2](https://github.com/user-attachments/assets/29ba59cc-6836-481a-8b53-2b7bec2e71c7)
##
## Task 1
This task involves understanding how to execute a C program within the RISC-V environment. It also includes determining the number of memory addresses occupied by the main section in the executed program.
<details> <summary>Click here to view the results</summary>

##
### Step-1: Sample C Program Code:
```c
#include <stdio.h>
int main() {
  	int i, sum = 0, n = 5;
  	for (i=1; i <= n; ++i) {
  	sum += i;
  	}
  	printf("Sum of numbers from 1 to %d is %d\n", n, sum);
  	return 0;
}
```
![screenshot-3](https://github.com/user-attachments/assets/610236e6-1d2c-4464-8e67-16aff8e5422e)

##
### Step-2: Compilation and Result
![screenshot-4](https://github.com/user-attachments/assets/06afcca1-f39b-4521-902d-7f3ca5bbfe7b)

##
### Step-3: Identifying the Main Section
![screenshot-5](https://github.com/user-attachments/assets/42f6541c-4816-437a-9eb6-b9717d51f325)

##
### Step-4: Calculate the Total Addresses
![screenshot-6](https://github.com/user-attachments/assets/f3ca4b90-454f-432c-8f15-80ae0b8ca3d5)
</details>

##
## Task 2
SPIKE is a simulator designed for the RISC-V architecture, enabling testing and debugging of RISC-V programs without requiring physical hardware. It emulates a RISC-V processor and cache, allowing the execution of programs or even a Linux kernel.PK (Proxy Kernel) serves as a lightweight environment to execute statically-linked RISC-V programs, functioning like a basic operating system. <br>
<br>
Perform the simulation by running a sample program (e.g., sum1ton.c) using both the gcc compiler and the RISC-V compiler. Verify that the outputs produced by both compilers are consistent when executed on the SPIKE simulator.
<details> <summary>Click here to view the results</summary>

##
### 1. Objective
To analyze the impact of -O1 and -Ofast optimization levels on a simple C program by compiling it with RISC-V GCC, simulating it using SPIKE, and comparing the generated RISC-V object dumps with performance observations.

##
### 2. Setup
#### 1. Spike Simulator:

- Command: `spike -d pk`
- Function: Simulates the RISC-V environment in debugging mode, providing detailed execution insights.

#### 2. Optimization Levels:

- `-O1`: Balanced optimizations for performance and stability.
- `-Ofast`: Aggressive optimizations focused on speed, potentially at the expense of strict correctness.

##
### 3. Process
#### 1. Program:
A simple C program was written to add two integers and print the result.
#### C Code Used:
```c
#include <stdio.h>
int main() {
  	int i, sum = 0, n = 100;
  	for (i=1; i <= n; ++i) {
  	sum += i;
  	}
  	printf("Sum of numbers from 1 to %d is %d\n", n, sum);
  	return 0;
}
```

#### 2. Compilation:
- Compiler: RISC-V GCC (`riscv64-unknown-elf-gcc`)
- Optimization levels: `-O1` and `-Ofast`.
- Build Automation: A Makefile was used to streamline compilation.

#### 3. Object Dump:
- Tool: `riscv64-unknown-elf-objdump`
- Purpose: Analyze and compare machine code generated by different optimization levels.

#### 4. Simulation:
- Tool: SPIKE
- Purpose: Emulate program execution and evaluate performance across optimization levels.

##
### Insights
#### 1. Optimization Levels:
- `-O1` applies fundamental optimizations, ensuring a balance between execution speed and reliability.
- `-Ofast` leverages advanced optimizations to enhance performance, potentially trading off strict compliance.

#### 2. Simulation Benefits:
- Provides detailed execution analysis without requiring physical RISC-V hardware.
- Facilitates a deeper understanding of how optimization affects performance and code structure.

##
### Step-1: Compilation and Executing the Program
#### C Code Used:
```c
#include <stdio.h>
int main() {
  	int i, sum = 0, n = 100;
  	for (i=1; i <= n; ++i) {
  	sum += i;
  	}
  	printf("Sum of numbers from 1 to %d is %d\n", n, sum);
  	return 0;
}
```
#### Commands:
 ```bash
  cat sum1ton.c
  gcc sum1ton.c
  ./a.out
  ```

![Screenshot-7](https://github.com/user-attachments/assets/b264661a-2d64-42ae-8a06-167aedcdf39c)

##
### Step-2: Compilation with Optimization Level -O1 and Generating an Object Dump
#### Commands:
```bash
riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
riscv64-unknown-elf-objdump -d sum1ton.o | less
```
![Screenshot-8](https://github.com/user-attachments/assets/898822e6-e8e5-4701-9191-b5a83205a0d4)

##
### Step-3: Executing the Program with SPIKE Debugger for -O1 Optimization Level
#### Commands:
```bash
spike -d pk sum1ton.o
```
![Screenshot-9](https://github.com/user-attachments/assets/ecf9c5ba-8679-484c-826f-8494a1c674dc)

##
### Step-4: Compilation with Optimization Level -Ofast and Generating an Object Dump
#### Commands:
```bash
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
riscv64-unknown-elf-objdump -d sum1ton.o | less
```
![Screenshot-10](https://github.com/user-attachments/assets/89752a95-8c76-4872-a572-356a31e124cd)

##
### Step-5: Executing the Program with SPIKE Debugger for -Ofast Optimization Level
#### Commands:
```bash
spike -d pk sum1ton.o
```
![Screenshot-11](https://github.com/user-attachments/assets/16ea5456-ee99-4a5a-b26a-344462faeb2d)
</details>

##
## Task 3
Analyzing RISC-V instruction types (R, I, S, B, U, J), decode 15 unique instructions from `riscv-objdump` to their 32-bit binary and hexadecimal formats.
<details> <summary>Click here to view the results</summary>

##
### Step 1: Understand the RISC-V Instruction Types
1. Identify and understand the six RISC-V instruction types: R, I, S, B, U, and J.
2. Focus on how these types are formatted in terms of opcode, function fields, and operands.

##
### Step 2: Extract 15 Unique RISC-V Instructions
1. Use riscv-objdump on your application code:
- Run the following command to disassemble your compiled RISC-V application:
```bash
riscv-objdump -d <application_binary>
```
2. Locate 15 unique instructions and note their assembly representation.

##
### Step 3: Decode Instructions to 32-Bit Formats
1. For each of the 15 instructions:
- Determine the 32-bit binary format using the RISC-V specification.
- Include the opcode, funct3, funct7, and other relevant fields based on their instruction types.

### Here's the analysis:

#### 1. Instruction: `LUI a2, 0x1` 
   - **Address:** `100b0`.
   - **Hexadecimal:** `00001637`.
   - **Type:** U-type (LUI).
   - **Opcode:** `0110111`. 
   - **Meaning:** Load the upper 20 bits of the immediate `0x1` into `a2`.

#### 2. Instruction: `AUIPC sp, 0x2`
   - **Address:** `100b4`
   - **Hexadecimal:** `00002117`.  
   - **Type:** U-type (AUIPC). 
   - **Opcode:** `0010111`.  
   - **Meaning:** Add the upper 20 bits of `0x2` to the program counter and store in `sp`.

#### 3. Instruction: `ADDI a0, sp, -16` 
   - **Address:** `100b8`.
   - **Hexadecimal:** `FF011513`.
   - **Type:** I-type (ADDI).
   - **Opcode:** `0010011`.
   - **Meaning:** Add the immediate value `-16` to `sp` and store the result in `a0`.

#### 4. Instruction: `ADDI a2, zero, 132`
   - **Address:** `100bc`. 
   - **Hexadecimal:** `08400613`.  
   - **Type:** I-type (ADDI).  
   - **Opcode:** `0010011`. 
   - **Meaning:** Load the immediate value `132` into `a2`.

#### 5. Instruction: `ADDI a0, a0, 384`
   - **Address:** `100c0`.  
   - **Hexadecimal:** `18055113`.  
   - **Type:** I-type (ADDI).  
   - **Opcode:** `0010011`. 
   - **Meaning:** Add the immediate value `384` to the value in `a0`.

#### 6. Instruction: `SD a0, 8(sp)`
   - **Address:** `100c4`.    
   - **Hexadecimal:** `00113423`.  
   - **Type:** S-type (SD).  
   - **Opcode:** `0100011`.  
   - **Meaning:** Store the value in `a0` at memory location `sp + 8`.

#### 7. Instruction: `JAL ra, <printf>` 
   - **Address:** `100c8`. 
   - **Hexadecimal:** `340000EF`.  
   - **Type:** J-type (JAL).  
   - **Opcode:** `1101111`.  
   - **Meaning:** Jump to the address of the `printf` function and store the return address in `ra`.

#### 8. Instruction: `RET` 
   - **Address:** `100cc`.    
   - **Hexadecimal:** `00008067`.  
   - **Type:** I-type (JALR).  
   - **Opcode:** `1100111`.  
   - **Meaning:** Return to the caller by jumping to the address in `ra`.

#### 9. Instruction: `AUIPC a5, 0xFFFFF`
   - **Address:** `100e0`.  
   - **Hexadecimal:** `FFF00797`.  
   - **Type:** U-type (AUIPC).  
   - **Opcode:** `0010111`.  
   - **Meaning:** Add the upper 20 bits of `0xFFFFF` to the program counter and store in `a5`.

#### 10. Instruction: `ADDI a5, a5, -224`
   - **Address:** `100e4`.  
   - **Hexadecimal:** `F2078793`.  
   - **Type:** I-type (ADDI).  
   - **Opcode:** `0010011`.  
   - **Meaning:** Add the immediate value `-224` to the value in `a5`.

#### 11. **Instruction:** `BEQ a5, zero, <target>` 
   - **Address:** `100e8`.    
   - **Hexadecimal:** `00078063`.  
   - **Type:** B-type (BEQ).  
   - **Opcode:** `1100011`.  
   - **Meaning:** Branch to `<target>` if `a5` equals `0`.

#### 12. Instruction: `AUIPC a0, 0x5`
   - **Address:** `100ec`.    
   - **Hexadecimal:** `00050517`.  
   - **Type:** U-type (AUIPC).  
   - **Opcode:** `0010111`.  
   - **Meaning:** Add the upper 20 bits of `0x5` to the program counter and store in `a0`.

#### 13. **Instruction:** `ADDI a0, a0, 272` 
   - **Address:** `100f0`.   
   - **Hexadecimal:** `11055113`.  
   - **Type:** I-type (ADDI).  
   - **Opcode:** `0010011`.  
   - **Meaning:** Add the immediate value `272` to the value in `a0`.

#### 14. **Instruction:** `ADDI gp, gp, -1780` 
   - **Address:** `10104`.  
   - **Hexadecimal:** `9C181293`.  
   - **Type:** I-type (ADDI).  
   - **Opcode:** `0010011`.  
   - **Meaning:** Add the immediate value `-1780` to the value in `gp`.

#### 15. **Instruction:** `AUIPC gp, 0x13`
   - **Address:** `10100`.   
   - **Hexadecimal:** `00013197`.  
   - **Type:** U-type (AUIPC).  
   - **Opcode:** `0010111`.  
   - **Meaning:** Add the upper 20 bits of `0x13` to the program counter and store in `gp`.

### Here is the information presented in a table format:

| **Addr**  | **Instruction**        | **Hex**     | **Binary**                   | **Type** | **Opcode** |
|-----------|------------------------|-------------|------------------------------|----------|------------|
| `100b0`   | `LUI a2, 0x1`          | `00001637`  | `00000000000000000001011000110111` | U-type   | `0110111`   |
| `100b4`   | `AUIPC sp, 0x2`        | `00002117`  | `00000000000000000010000100010111` | U-type   | `0010111`   |
| `100b8`   | `ADDI a0, sp, -16`     | `FF011513`  | `11111111000000010001010100010011` | I-type   | `0010011`   |
| `100bc`   | `ADDI a2, zero, 132`   | `08400613`  | `00001000010000000000011000010011` | I-type   | `0010011`   |
| `100c0`   | `ADDI a0, a0, 384`     | `18055113`  | `00011000000001010101000100010011` | I-type   | `0010011`   |
| `100c4`   | `SD a0, 8(sp)`         | `00113423`  | `00000000000100010011010000100011` | S-type   | `0100011`   |
| `100c8`   | `JAL ra, <printf>`     | `340000EF`  | `00110100000000000000000011101111` | J-type   | `1101111`   |
| `100cc`   | `RET`                  | `00008067`  | `00000000000000001000000001100111` | I-type   | `1100111`   |
| `100e0`   | `AUIPC a5, 0xFFFFF`    | `FFF00797`  | `11111111111100000000011110010111` | U-type   | `0010111`   |
| `100e4`   | `ADDI a5, a5, -224`    | `F2078793`  | `11110010000001111000011110010011` | I-type   | `0010011`   |
| `100e8`   | `BEQ a5, zero, target` | `00078063`  | `00000000000001111000000001100011` | B-type   | `1100011`   |
| `100ec`   | `AUIPC a0, 0x5`        | `00050517`  | `00000000000001010000010100010111` | U-type   | `0010111`   |
| `100f0`   | `ADDI a0, a0, 272`     | `11055113`  | `00010001000001010101000100010011` | I-type   | `0010011`   |
| `10104`   | `ADDI gp, gp, -1780`   | `9C181293`  | `10011100000110000001001010010011` | I-type   | `0010011`   |
| `10100`   | `AUIPC gp, 0x13`       | `00013197`  | `00000000000000010011000110010111` | U-type   | `0010111`   |

![Screenshot-14](https://github.com/user-attachments/assets/894f1528-6dd9-4adf-a121-f60d9b8c2995)

