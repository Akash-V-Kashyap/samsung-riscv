# Samsung-RISCV
RISC-V is an open-standard instruction set architecture (ISA) rooted in the principles of Reduced Instruction Set Computer (RISC) design. Its open-source nature makes it freely available to anyone, enabling widespread adoption and fostering innovation in the development of custom processors tailored to specific use cases.

## Basic Details ðŸš€
#### -  Name: Akash V Kashyap
#### - College: Dayananda Sagar College of Engineering, Bengalore 560078
#### - Email ID: akashvkashyap@gmail.com
#### - GitHub Profile: Akash-V-Kashyap 
#### - LinkedIN Profile: [Akash V Kashyap](https://www.linkedin.com/in/akash-v-kashyap-336003261/)

## 
### 1. Download the Oracle Virtual Machine
![screenshot-1](https://github.com/user-attachments/assets/dd7eed6f-afc5-4a4d-9d28-5c94b033e330)

##
### 2. What is OpenLane?
OpenLane is an advanced silicon implementation platform that integrates open-source tools like Yosys, OpenROAD, Magic, KLayout, and other open-source or proprietary utilities.

##
### 3. Installed OpenLane in Ubuntu
![screenshot-2](https://github.com/user-attachments/assets/29ba59cc-6836-481a-8b53-2b7bec2e71c7)
##
## Task 1
This task involves understanding how to execute a C program within the RISC-V environment. It also includes determining the number of memory addresses occupied by the main section in the executed program.
<details> <summary>Click here to view the results</summary>

##
### Step-1: Sample C Program Code:
```c
#include <stdio.h>
int main() {
  	int i, sum = 0, n = 5;
  	for (i=1; i <= n; ++i) {
  	sum += i;
  	}
  	printf("Sum of numbers from 1 to %d is %d\n", n, sum);
  	return 0;
}
```
![screenshot-3](https://github.com/user-attachments/assets/610236e6-1d2c-4464-8e67-16aff8e5422e)

##
### Step-2: Compilation and Result
![screenshot-4](https://github.com/user-attachments/assets/06afcca1-f39b-4521-902d-7f3ca5bbfe7b)

##
### Step-3: Identifying the Main Section
![screenshot-5](https://github.com/user-attachments/assets/42f6541c-4816-437a-9eb6-b9717d51f325)

##
### Step-4: Calculate the Total Addresses
![screenshot-6](https://github.com/user-attachments/assets/f3ca4b90-454f-432c-8f15-80ae0b8ca3d5)
</details>

##
## Task 2
SPIKE is a simulator designed for the RISC-V architecture, enabling testing and debugging of RISC-V programs without requiring physical hardware. It emulates a RISC-V processor and cache, allowing the execution of programs or even a Linux kernel.PK (Proxy Kernel) serves as a lightweight environment to execute statically-linked RISC-V programs, functioning like a basic operating system. <br>
<br>
Perform the simulation by running a sample program (e.g., sum1ton.c) using both the gcc compiler and the RISC-V compiler. Verify that the outputs produced by both compilers are consistent when executed on the SPIKE simulator.
<details> <summary>Click here to view the results</summary>

##
### 1. Objective
To analyze the impact of -O1 and -Ofast optimization levels on a simple C program by compiling it with RISC-V GCC, simulating it using SPIKE, and comparing the generated RISC-V object dumps with performance observations.

##
### 2. Setup
#### 1. Spike Simulator:

- Command: `spike -d pk`
- Function: Simulates the RISC-V environment in debugging mode, providing detailed execution insights.

#### 2. Optimization Levels:

- `-O1`: Balanced optimizations for performance and stability.
- `-Ofast`: Aggressive optimizations focused on speed, potentially at the expense of strict correctness.

##
### 3. Process
#### 1. Program:
A simple C program was written to add two integers and print the result.
#### C Code Used:
```c
#include <stdio.h>
int main() {
  	int i, sum = 0, n = 100;
  	for (i=1; i <= n; ++i) {
  	sum += i;
  	}
  	printf("Sum of numbers from 1 to %d is %d\n", n, sum);
  	return 0;
}
```

#### 2. Compilation:
- Compiler: RISC-V GCC (`riscv64-unknown-elf-gcc`)
- Optimization levels: `-O1` and `-Ofast`.
- Build Automation: A Makefile was used to streamline compilation.

#### 3. Object Dump:
- Tool: `riscv64-unknown-elf-objdump`
- Purpose: Analyze and compare machine code generated by different optimization levels.

#### 4. Simulation:
- Tool: SPIKE
- Purpose: Emulate program execution and evaluate performance across optimization levels.

##
### Insights
#### 1. Optimization Levels:
- `-O1` applies fundamental optimizations, ensuring a balance between execution speed and reliability.
- `-Ofast` leverages advanced optimizations to enhance performance, potentially trading off strict compliance.

#### 2. Simulation Benefits:
- Provides detailed execution analysis without requiring physical RISC-V hardware.
- Facilitates a deeper understanding of how optimization affects performance and code structure.

##
### Step-1: Compilation and Executing the Program
#### C Code Used:
```c
#include <stdio.h>
int main() {
  	int i, sum = 0, n = 100;
  	for (i=1; i <= n; ++i) {
  	sum += i;
  	}
  	printf("Sum of numbers from 1 to %d is %d\n", n, sum);
  	return 0;
}
```
#### Commands:
 ```bash
  cat sum1ton.c
  gcc sum1ton.c
  ./a.out
  ```

![Screenshot-7](https://github.com/user-attachments/assets/b264661a-2d64-42ae-8a06-167aedcdf39c)

##
### Step-2: Compilation with Optimization Level -O1 and Generating an Object Dump
#### Commands:
```bash
riscv64-unknown-elf-gcc -O1 -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
riscv64-unknown-elf-objdump -d sum1ton.o | less
```
![Screenshot-8](https://github.com/user-attachments/assets/898822e6-e8e5-4701-9191-b5a83205a0d4)

##
### Step-3: Executing the Program with SPIKE Debugger for -O1 Optimization Level
#### Commands:
```bash
spike -d pk sum1ton.o
```
![Screenshot-9](https://github.com/user-attachments/assets/ecf9c5ba-8679-484c-826f-8494a1c674dc)

##
### Step-4: Compilation with Optimization Level -Ofast and Generating an Object Dump
#### Commands:
```bash
riscv64-unknown-elf-gcc -Ofast -mabi=lp64 -march=rv64i -o sum1ton.o sum1ton.c
riscv64-unknown-elf-objdump -d sum1ton.o | less
```
![Screenshot-10](https://github.com/user-attachments/assets/89752a95-8c76-4872-a572-356a31e124cd)

##
### Step-5: Executing the Program with SPIKE Debugger for -Ofast Optimization Level
#### Commands:
```bash
spike -d pk sum1ton.o
```
![Screenshot-11](https://github.com/user-attachments/assets/16ea5456-ee99-4a5a-b26a-344462faeb2d)
</details>

##
## Task 3
Analyzing RISC-V instruction types (R, I, S, B, U, J), decode 15 unique instructions from `riscv-objdump` to their 32-bit binary and hexadecimal formats.
<details> <summary>Click here to view the results</summary>

##
### Step 1: Understand the RISC-V Instruction Types
1. Identify and understand the six RISC-V instruction types: R, I, S, B, U, and J.
2. Focus on how these types are formatted in terms of opcode, function fields, and operands.

##
### Step 2: Extract 15 Unique RISC-V Instructions
1. Use riscv-objdump on your application code:
- Run the following command to disassemble your compiled RISC-V application:
```bash
riscv-objdump -d <application_binary>
```
2. Locate 15 unique instructions and note their assembly representation.

##
### Step 3: Decode Instructions to 32-Bit Formats
1. For each of the 15 instructions:
- Determine the 32-bit binary format using the RISC-V specification.
- Include the opcode, funct3, funct7, and other relevant fields based on their instruction types.

### Here's the analysis:

#### 1. Instruction: `LUI a2, 0x1` 
   - **Address:** `100b0`.
   - **Hexadecimal:** `00001637`.
   - **Type:** U-type (LUI).
   - **Opcode:** `0110111`. 
   - **Meaning:** Load the upper 20 bits of the immediate `0x1` into `a2`.

#### 2. Instruction: `AUIPC sp, 0x2`
   - **Address:** `100b4`
   - **Hexadecimal:** `00002117`.  
   - **Type:** U-type (AUIPC). 
   - **Opcode:** `0010111`.  
   - **Meaning:** Add the upper 20 bits of `0x2` to the program counter and store in `sp`.

#### 3. Instruction: `ADDI a0, sp, -16` 
   - **Address:** `100b8`.
   - **Hexadecimal:** `FF011513`.
   - **Type:** I-type (ADDI).
   - **Opcode:** `0010011`.
   - **Meaning:** Add the immediate value `-16` to `sp` and store the result in `a0`.

#### 4. Instruction: `ADDI a2, zero, 132`
   - **Address:** `100bc`. 
   - **Hexadecimal:** `08400613`.  
   - **Type:** I-type (ADDI).  
   - **Opcode:** `0010011`. 
   - **Meaning:** Load the immediate value `132` into `a2`.

#### 5. Instruction: `ADDI a0, a0, 384`
   - **Address:** `100c0`.  
   - **Hexadecimal:** `18055113`.  
   - **Type:** I-type (ADDI).  
   - **Opcode:** `0010011`. 
   - **Meaning:** Add the immediate value `384` to the value in `a0`.

#### 6. Instruction: `SD a0, 8(sp)`
   - **Address:** `100c4`.    
   - **Hexadecimal:** `00113423`.  
   - **Type:** S-type (SD).  
   - **Opcode:** `0100011`.  
   - **Meaning:** Store the value in `a0` at memory location `sp + 8`.

#### 7. Instruction: `JAL ra, <printf>` 
   - **Address:** `100c8`. 
   - **Hexadecimal:** `340000EF`.  
   - **Type:** J-type (JAL).  
   - **Opcode:** `1101111`.  
   - **Meaning:** Jump to the address of the `printf` function and store the return address in `ra`.

#### 8. Instruction: `RET` 
   - **Address:** `100cc`.    
   - **Hexadecimal:** `00008067`.  
   - **Type:** I-type (JALR).  
   - **Opcode:** `1100111`.  
   - **Meaning:** Return to the caller by jumping to the address in `ra`.

#### 9. Instruction: `AUIPC a5, 0xFFFFF`
   - **Address:** `100e0`.  
   - **Hexadecimal:** `FFF00797`.  
   - **Type:** U-type (AUIPC).  
   - **Opcode:** `0010111`.  
   - **Meaning:** Add the upper 20 bits of `0xFFFFF` to the program counter and store in `a5`.

#### 10. Instruction: `ADDI a5, a5, -224`
   - **Address:** `100e4`.  
   - **Hexadecimal:** `F2078793`.  
   - **Type:** I-type (ADDI).  
   - **Opcode:** `0010011`.  
   - **Meaning:** Add the immediate value `-224` to the value in `a5`.

#### 11. **Instruction:** `BEQ a5, zero, <target>` 
   - **Address:** `100e8`.    
   - **Hexadecimal:** `00078063`.  
   - **Type:** B-type (BEQ).  
   - **Opcode:** `1100011`.  
   - **Meaning:** Branch to `<target>` if `a5` equals `0`.

#### 12. Instruction: `AUIPC a0, 0x5`
   - **Address:** `100ec`.    
   - **Hexadecimal:** `00050517`.  
   - **Type:** U-type (AUIPC).  
   - **Opcode:** `0010111`.  
   - **Meaning:** Add the upper 20 bits of `0x5` to the program counter and store in `a0`.

#### 13. **Instruction:** `ADDI a0, a0, 272` 
   - **Address:** `100f0`.   
   - **Hexadecimal:** `11055113`.  
   - **Type:** I-type (ADDI).  
   - **Opcode:** `0010011`.  
   - **Meaning:** Add the immediate value `272` to the value in `a0`.

#### 14. **Instruction:** `ADDI gp, gp, -1780` 
   - **Address:** `10104`.  
   - **Hexadecimal:** `9C181293`.  
   - **Type:** I-type (ADDI).  
   - **Opcode:** `0010011`.  
   - **Meaning:** Add the immediate value `-1780` to the value in `gp`.

#### 15. **Instruction:** `AUIPC gp, 0x13`
   - **Address:** `10100`.   
   - **Hexadecimal:** `00013197`.  
   - **Type:** U-type (AUIPC).  
   - **Opcode:** `0010111`.  
   - **Meaning:** Add the upper 20 bits of `0x13` to the program counter and store in `gp`.

### Here is the information presented in a table format:

| **Addr**  | **Instruction**        | **Hex**     | **Binary**                   | **Type** | **Opcode** |
|-----------|------------------------|-------------|------------------------------|----------|------------|
| `100b0`   | `LUI a2, 0x1`          | `00001637`  | `00000000000000000001011000110111` | U-type   | `0110111`   |
| `100b4`   | `AUIPC sp, 0x2`        | `00002117`  | `00000000000000000010000100010111` | U-type   | `0010111`   |
| `100b8`   | `ADDI a0, sp, -16`     | `FF011513`  | `11111111000000010001010100010011` | I-type   | `0010011`   |
| `100bc`   | `ADDI a2, zero, 132`   | `08400613`  | `00001000010000000000011000010011` | I-type   | `0010011`   |
| `100c0`   | `ADDI a0, a0, 384`     | `18055113`  | `00011000000001010101000100010011` | I-type   | `0010011`   |
| `100c4`   | `SD a0, 8(sp)`         | `00113423`  | `00000000000100010011010000100011` | S-type   | `0100011`   |
| `100c8`   | `JAL ra, <printf>`     | `340000EF`  | `00110100000000000000000011101111` | J-type   | `1101111`   |
| `100cc`   | `RET`                  | `00008067`  | `00000000000000001000000001100111` | I-type   | `1100111`   |
| `100e0`   | `AUIPC a5, 0xFFFFF`    | `FFF00797`  | `11111111111100000000011110010111` | U-type   | `0010111`   |
| `100e4`   | `ADDI a5, a5, -224`    | `F2078793`  | `11110010000001111000011110010011` | I-type   | `0010011`   |
| `100e8`   | `BEQ a5, zero, target` | `00078063`  | `00000000000001111000000001100011` | B-type   | `1100011`   |
| `100ec`   | `AUIPC a0, 0x5`        | `00050517`  | `00000000000001010000010100010111` | U-type   | `0010111`   |
| `100f0`   | `ADDI a0, a0, 272`     | `11055113`  | `00010001000001010101000100010011` | I-type   | `0010011`   |
| `10104`   | `ADDI gp, gp, -1780`   | `9C181293`  | `10011100000110000001001010010011` | I-type   | `0010011`   |
| `10100`   | `AUIPC gp, 0x13`       | `00013197`  | `00000000000000010011000110010111` | U-type   | `0010111`   |

![Screenshot-14](https://github.com/user-attachments/assets/894f1528-6dd9-4adf-a121-f60d9b8c2995)
</details>

##
## Task 4
Performing a functional simulation of a RISC-V Core using the Verilog netlist and testbench, including waveform capture
<details> <summary>Click here to view the results</summary>

##
### Overview of Icarus Verilog and GTKWave

- **`Icarus Verilog`** is a popular open-source Verilog simulation and synthesis tool that supports a wide range of Verilog standards. It is used to simulate and test hardware designs before implementation.
- **`GTKWave`** is a versatile waveform viewer compatible with Unix and Windows systems. It supports viewing signal activity from simulation output files such as VCD (Value Change Dump) and EVCD (Extended Value Change Dump), providing an intuitive interface for debugging and analysis.

##
### Installing Required Tools  

#### 1. Install `GTKWave` waveform viewer
To install GTKWave, execute the following commands in the terminal:
```bash
sudo apt update
sudo apt install gtkwave
```

#### 2. Install `Icarus Verilog` simulation tool  
To install Icarus Verilog, run the following command:  
```bash
sudo apt-get install iverilog  
```

![Screenshot-15](https://github.com/user-attachments/assets/6e318b23-9497-4b50-96df-fe14756fdbb6)

##
### Steps for Performing Functional Simulation of RISC-V CORE 

##
### Step 1: Create a new directory  
- Use the following command to create a directory with your name:  
```bash
mkdir <your_name>
```

##
### Step 2: Create Verilog and Testbench Files  
- Inside the directory, create two files using the `gedit` command:  
```bash
gedit akash_rv32i.v
gedit akash_rv32i_tb.v
```

##
### Step 3: Add Code to Files 
- Copy the required Verilog and testbench code from the reference GitHub repository and paste it into the respective files.

### Verilog Code :

##
### Step 4: Simulate the Code**  
- To compile and simulate the Verilog code, run:  
```bash
iverilog -o akash_rv32i akash_rv32i.v akash_rv32i_tb.v  
./akash_rv32i
```

##
### Step 5: View the Simulation Waveform in GTKWave**  
- To visualize the waveform, execute:  
```bash
gtkwave akash_rv32i.vcd
```

##
### Output Waveforms

##
### Instruction - 1: `ADD R6, R1, R2`
   1. **Address**: `0x02208300`
   2. **Operation**: `r6 = r1 + r2`
   3. **Result**: `REG[7] = 1 + 2 = 3`

![Screenshot-16](https://github.com/user-attachments/assets/ea5a91c7-020c-4b46-8f66-329b234d223a)

##
### Instruction - 2: `SUB R7, R1, R2`
   1. **Address**: `0x02209380` 
   2. **Operation**: `r7 = r1 - r2`  
   3. **Result**: `REG[7] = 1 - 2 = -1`

![Screenshot-17](https://github.com/user-attachments/assets/c3b124e6-7935-440c-bc51-eedf21f6989f)

##
### Instruction - 3: `AND R8, R1, R3`
   1. **Address**: `0x0230A400`
   2. **Operation**: `r8 = r1 & r3`  
   3. **Result**: `REG[8] = 1 & 3 = 1`

![Screenshot-18](https://github.com/user-attachments/assets/ed8ca11a-3a55-48ec-be04-5a0d0803ede6)

##
### Instruction - 4: `OR R9, R2, R5`
   1. **Address**: `0x02513480`
   2. **Operation**: `r9 = r2 | r5`  
   3. **Result**: `REG[9] = 2 | 5 = 7`

![Screenshot-19](https://github.com/user-attachments/assets/cb1ea788-4882-40e7-9aa9-a9a0ac8ca719)

##
### Instruction - 5: `XOR R10, R1, R4`
   1. **Address**: `0x0240C500`
   2. **Operation**: `r10 = r1 ^ r4`  
   3. **Result**: `REG[10] = 1 ^ 4 = 5`

![Screenshot-20](https://github.com/user-attachments/assets/09b026bb-cfa6-49a9-88a4-b3fd9cd9955a)

##
### Instruction - 6: `SLT R11, R2, R4`
   1. **Address**: `0x02415580`
   2. **Operation**: `r11 = (r2 < r4) ? 1 : 0`  
   3. **Result**: `REG[11] = (2 < 4) = 1`

![Screenshot-21](https://github.com/user-attachments/assets/8d1eb180-5e19-4aaa-9dea-3b70abd07fc3)

##
### Instruction - 7: `ADDI R12, R4, 5`
   1. **Address**: `0x00520600`
   2. **Operation**: `r12 = r4 + 5`  
   3. **Result**: `REG[12] = 4 + 5 = 9`

![Screenshot-22](https://github.com/user-attachments/assets/8e7b340f-6939-45de-b844-fc9a7064ae93)

##
### Instruction - 8: `SW R3, R1, 2`
   1. **Address**: `0x00209181`
   2. **Operation**: Store `r3` at `DM[r1 + 2]`  
   3. **Result**: `DM[3] = REG[3] = 3`

![Screenshot-23](https://github.com/user-attachments/assets/95557081-a790-40be-9442-9bfea0a262c1)

##
### Instruction - 9: `LW R13, R1, 2`
   1. **Address**: `0x00208681` 
   2. **Operation**: Load `DM[r1 + 2]` into `r13`  
   3. **Result**: `REG[13] = DM[3] = 3`

![Screenshot-24](https://github.com/user-attachments/assets/2fde8f1c-b949-4792-84b2-91c67e9b7351)

##
### Instruction - 10: `BEQ R0, R0, 15`
   1. **Address**: `0x00F00002` 
   2. **Operation**: `NPC = 15` (always true, skips next instructions)  
   3. **Result**: `REG[13] = DM[3] = 3`

![Screenshot-24](https://github.com/user-attachments/assets/2fde8f1c-b949-4792-84b2-91c67e9b7351)

##
### Instruction - 11: `ADD R14, R2, R2`
   1. **Address**: `0x00210700`
   2. **Operation**: `r14 = r2 + r2`  
   3. **Result**: `REG[14] = 2 + 2 = 4`

![Screenshot-25](https://github.com/user-attachments/assets/75509783-98fd-42a7-8b9d-69492811774d)

## Full Waveform:
![Screenshot-26](https://github.com/user-attachments/assets/91196594-6177-4726-a438-9d0e51bc77d0)
